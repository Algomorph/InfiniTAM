// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM
// Modified code: Copyright 2020 Gregory Kramida
#pragma once

//stdlib
#include <vector>

//boost
#include <boost/filesystem.hpp>

//local
#include "../../InputSource/ImageSourceEngine.h"
#include "../../InputSource/IMUSourceEngine.h"
#include "../../InputSource/FFMPEGWriter.h"
#include "../../ITMLib/Engines/Main/FusionAlgorithm.h"
#include "../../ITMLib/Objects/Tracking/CameraTrackingState.h"
#include "../../ITMLib/Utils/Configuration/Configuration.h"
#include "../../ORUtils/FileUtils.h"
#include "../../ORUtils/NVTimer.h"
#include "../../ITMLib/Engines/Telemetry/TelemetryRecorderLegacy.h"
#include "../../ITMLib/Utils/Configuration/AutomaticRunSettings.h"
#include "../../ITMLib/Engines/ImageProcessing/Interface/ImageProcessingEngineInterface.h"

namespace InfiniTAM {
namespace Engine { //TODO: retching from the overuse of the word "Engine"
class UIEngine {
private:

	enum MainLoopAction {
		PROCESS_PAUSED, PROCESS_FRAME, PROCESS_VIDEO, EXIT, PROCESS_N_FRAMES
	} main_loop_action;

	enum MouseOperation{
		IDLE,
		VIEW_ROTATION,
		VIEW_PANNING,
		VIEW_DOLLYING
	};

	struct UIColourMode {
		const char* name;
		ITMLib::FusionAlgorithm::GetImageType type;

		UIColourMode(const char* _name, ITMLib::FusionAlgorithm::GetImageType _type)
				: name(_name), type(_type) {}
	};
	std::vector<UIColourMode> colourModes_main, colourModes_freeview;

	int current_colour_mode;

	ITMLib::AutomaticRunSettings automatic_run_settings;

	InputSource::ImageSourceEngine* image_source_engine;
	InputSource::IMUSourceEngine* imu_source_engine;
	ITMLib::FusionAlgorithm* main_engine;
	ITMLib::ImageProcessingEngineInterface* image_processing_engine;

	StopWatchInterface* timer_instant;
	StopWatchInterface* timer_average;

	// For UI layout
	static const int NUM_WIN = 3;
	Vector4f window_corners[NUM_WIN]; // (x1, y1, x2, y2)
	Vector2i window_size;
	uint textureId[NUM_WIN];
	UChar4Image* output_images[NUM_WIN];
	ITMLib::FusionAlgorithm::GetImageType output_image_types[NUM_WIN];

	UChar4Image* input_RGB_image;
	ShortImage* input_raw_depth_image;
	ITMLib::IMUMeasurement* input_IMU_measurement;

	bool freeview_active;
	bool integration_active;
	ORUtils::SE3Pose freeview_pose;
	ITMLib::Intrinsics freeview_intrinsics;

	MouseOperation current_mouse_operation;
	Vector2i last_mouse_click_position;
	bool mouse_warped; // To avoid the extra motion generated by glutWarpPointer

	int processed_frame_count;
	bool image_recording_enabled;

	InputSource::FFMPEGWriter* reconstruction_video_writer = nullptr;
	bool add_input_to_reconstruction_video = false;
	InputSource::FFMPEGWriter* RGB_video_writer = nullptr;
	InputSource::FFMPEGWriter* depth_video_writer = nullptr;
public:
	static UIEngine& Instance() {
		static UIEngine instance;
		return instance;
	}

	static void GlutDisplayFunction();
	static void GlutIdleFunction();
	static void GlutKeyUpFunction(unsigned char key, int x, int y);
	static void GlutMouseButtonFunction(int button, int state, int x, int y);
	static void GlutMouseMoveFunction(int x, int y);
	static void GlutMouseWheelFunction(int button, int dir, int x, int y);

	const Vector2i& GetWindowSize() const { return window_size; }

	float current_frame_processing_time;
	int current_frame_index;
	int output_image_frame_index = -1;
	ITMLib::CameraTrackingState::TrackingResult tracking_result;
	std::string output_path;
	bool needs_refresh;

	bool shutdown_requested = false;
	UChar4Image* image_to_save;

	void Initialize(int& argc, char** argv, InputSource::ImageSourceEngine* imageSource, InputSource::IMUSourceEngine* imuSource,
	                ITMLib::FusionAlgorithm* main_engine, const ITMLib::configuration::Configuration& configuration);
	void Shutdown();

	void Run();
	void PrintProcessingFrameHeader() const;
	void ProcessFrame();

	void GetScreenshot(UChar4Image* dest) const;
	void SaveScreenshot(const char* filename) const;

	void SkipFrames(int number_of_frames_to_skip);
	void UpdateOutputImages();
	void RecordCurrentReconstructionFrameToVideo();
	void RecordDepthAndRGBInputToVideo();
	void RecordDepthAndRGBInputToImages();

	std::string GenerateNextFrameOutputPath() const;
	std::string GenerateCurrentFrameOutputPath() const;
	std::string GeneratePreviousFrameOutputPath() const;
};
} // namespace Engine -- bleh?
} // namespace InfiniTAM
