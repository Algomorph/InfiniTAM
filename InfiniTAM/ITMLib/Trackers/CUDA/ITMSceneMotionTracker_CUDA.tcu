//  ================================================================
//  Created by Gregory Kramida on 10/18/17.
//  Copyright (c) 2017-2025 Gregory Kramida
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at

//  http://www.apache.org/licenses/LICENSE-2.0

//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//  ================================================================

#include "ITMSceneMotionTracker_CUDA.h"
#include "../../Utils/ITMCUDAUtils.h"
#include "../../../ORUtils/CUDADefines.h"
#include "../../Objects/Views/ITMView.h"
#include "../../Utils/ITMLibSettings.h"

using namespace ITMLib;

template<typename TVoxelCanonical>
__global__ void computeWarpUpdate_device(TVoxelCanonical* canonicalVoxelArray,
                                         const ITMHashEntry* hashTable,
                                         int noTotalEntries) {
//	Vector3i globalPos;
//	int entryId = visibleEntryIDs[blockIdx.x];
//
//	const ITMHashEntry &currentHashEntry = hashTable[entryId];
//
//	if (currentHashEntry.ptr < 0) return;
//
//	globalPos = currentHashEntry.pos.toInt() * SDF_BLOCK_SIZE;
//
//	TVoxelCanonical *localVoxelBlock = &(localVBA[currentHashEntry.ptr * SDF_BLOCK_SIZE3]);
//
//	int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;
	//TODO

}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::CalculateWarpGradient(
		ITMScene<TVoxelCanonical, TIndex>* canonicalScene,
		ITMScene<TVoxelLive, TIndex>* liveScene) {
	TVoxelCanonical* canonicalVoxels = canonicalScene->localVBA.GetVoxelBlocks();
	const ITMHashEntry* canonicalHashTable = canonicalScene->index.GetEntries();
	typename TIndex::IndexCache canonicalCache;

	const TVoxelLive* liveVoxels = liveScene->localVBA.GetVoxelBlocks();
	const ITMHashEntry* liveHashTable = liveScene->index.GetEntries();
	typename TIndex::IndexCache liveCache;

	int noTotalEntries = canonicalScene->index.noTotalEntries;
	//float maxVectorUpdate = 0.0f;

	dim3 cudaBlockSize(SDF_BLOCK_SIZE, SDF_BLOCK_SIZE, SDF_BLOCK_SIZE);
	dim3 gridSize(SDF_LOCAL_BLOCK_NUM / 16, 16);

	{// compute warp updates for all voxel hash blocks
		//TODO: figure out the cuda blocks / data correspondences here to pull the proper voxel out
		computeWarpUpdate_device << < gridSize, cudaBlockSize >> >
		                                        (canonicalVoxels, canonicalHashTable, noTotalEntries);
	}

	{// apply the warp updates to all voxel hash blocks
		//TODO
	}

	DIEWITHEXCEPTION("Scene tracking iteration not yet implemented");
	//return 0.f;
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void
ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::FuseFrame(
		ITMScene<TVoxelCanonical, TIndex>* canonicalScene,
		ITMScene<TVoxelLive, TIndex>* liveScene) {
	DIEWITHEXCEPTION("Scene tracking iteration not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::ITMSceneMotionTracker_CUDA(
		const ITMLibSettings* settings)
		:
		ITMSceneMotionTracker<TVoxelCanonical, TVoxelLive, TIndex>(settings) {

}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::AllocateNewCanonicalHashBlocks(
		ITMScene<TVoxelCanonical, TIndex>* canonicalScene, ITMScene<TVoxelLive, TIndex>* liveScene) {
	DIEWITHEXCEPTION("Scene boundary voxel allocation not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::WarpCanonicalToLive(
		ITMScene<TVoxelCanonical, TIndex>* canonicalScene, ITMScene<TVoxelLive, TIndex>* liveScene) {
	DIEWITHEXCEPTION("Warp application not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::ApplyWarpUpdateToLive(ITMScene<TVoxelCanonical, TIndex>* canonicalScene, ITMScene<TVoxelLive, TIndex>* sourceLiveScene) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::ApplyWarpFieldToLive(ITMScene<TVoxelCanonical, TIndex>* canonicalScene, ITMScene<TVoxelLive, TIndex>* sourceLiveScene) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
float ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::ApplyWarpUpdateToWarp(
		ITMScene<TVoxelCanonical, TIndex>* canonicalScene, ITMScene<TVoxelLive, TIndex>* liveScene) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::ApplySmoothingToGradient(ITMScene<TVoxelCanonical, TIndex>* canonicalScene, ITMScene<TVoxelLive, TIndex>* liveScene) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::ClearOutWarps(
		ITMScene<TVoxelCanonical, TIndex>* canonicalScene) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not yet implemented");
}

template<typename TVoxelCanonical, typename TVoxelLive, typename TIndex>
void ITMSceneMotionTracker_CUDA<TVoxelCanonical, TVoxelLive, TIndex>::MarkBoundaryVoxels(
		ITMScene<TVoxelLive, TIndex>* liveScene) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not yet implemented");
}
