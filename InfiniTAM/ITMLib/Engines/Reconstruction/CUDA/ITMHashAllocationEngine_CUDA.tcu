//  ================================================================
//  Created by Gregory Kramida on 10/8/19.
//  Copyright (c) 2019 Gregory Kramida
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at

//  http://www.apache.org/licenses/LICENSE-2.0

//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//  ================================================================
#include "ITMHashAllocationEngine_CUDA.h"
#include "ITMHashAllocationEngine_CUDA_Kernels.h"
#include "../../../Objects/RenderStates/ITMRenderState_VH.h"

using namespace ITMLib;


template<typename TVoxel, typename TWarp>
ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::ITMHashAllocationEngine_CUDA() :
		targetSceneHashBlockStates(
				new ORUtils::MemoryBlock<unsigned char>(ITMVoxelBlockHash::noTotalEntries, MEMORYDEVICE_CUDA)),
		sourceSceneHashBlockStates(
				new ORUtils::MemoryBlock<unsigned char>(ITMVoxelBlockHash::noTotalEntries, MEMORYDEVICE_CUDA)),
		targetSceneHashBlockCoordinates(
				new ORUtils::MemoryBlock<Vector3s>(ITMVoxelBlockHash::noTotalEntries, MEMORYDEVICE_CUDA)) {

}

template<typename TVoxel, typename TWarp>
ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::~ITMHashAllocationEngine_CUDA() {
	delete targetSceneHashBlockStates;
	delete sourceSceneHashBlockStates;
	delete targetSceneHashBlockCoordinates;
}

template<typename TVoxel, typename TWarp>
void ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::AllocateFromDepth(
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* scene,
		const ITMView* view, const ITMTrackingState* trackingState, const ITMRenderState* renderState,
		bool onlyUpdateVisibleList, bool resetVisibleList) {

	Vector2i depthImgSize = view->depth->noDims;
	float voxelSize = scene->sceneParams->voxelSize;

	Matrix4f M_d, invM_d;
	Vector4f projParams_d, invProjParams_d;

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;
	if (resetVisibleList) renderState_vh->noVisibleEntries = 0;

	M_d = trackingState->pose_d->GetM();
	M_d.inv(invM_d);

	projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
	invProjParams_d = projParams_d;
	invProjParams_d.x = 1.0f / invProjParams_d.x;
	invProjParams_d.y = 1.0f / invProjParams_d.y;

	float mu = scene->sceneParams->mu;

	float* depth = view->depth->GetData(MEMORYDEVICE_CUDA);
	int* voxelAllocationList = scene->localVBA.GetAllocationList();
	int* excessAllocationList = scene->index.GetExcessAllocationList();
	ITMHashEntry* hashTable = scene->index.GetEntries();
	ITMHashSwapState* swapStates = scene->Swapping() ? scene->globalCache->GetSwapStates(true) : 0;

	uchar* entryAllocationTypes_device = this->sourceSceneHashBlockStates->GetData(MEMORYDEVICE_CUDA);
	Vector3s* allocationBlockCoordinates_device = this->targetSceneHashBlockCoordinates->GetData(MEMORYDEVICE_CUDA);

	int noTotalEntries = scene->index.noTotalEntries;

	int* visibleEntryIDs_device = renderState_vh->GetVisibleEntryIDs();
	uchar* hashBlockVisibilityTypes_device = renderState_vh->GetEntriesVisibleType();

	dim3 cudaBlockSizeHV(16, 16);
	dim3 gridSizeHV((int) ceil((float) depthImgSize.x / (float) cudaBlockSizeHV.x),
	                (int) ceil((float) depthImgSize.y / (float) cudaBlockSizeHV.y));

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) noTotalEntries / (float) cudaBlockSizeAL.x));

	dim3 cudaBlockSizeVS(256, 1);
	dim3 gridSizeVS((int) ceil((float) renderState_vh->noVisibleEntries / (float) cudaBlockSizeVS.x));

	float oneOverHashEntrySize = 1.0f / (voxelSize * SDF_BLOCK_SIZE);//m

	ORUtils::MemoryBlock<bool> collisionDetected(1, true, true);

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->noAllocatedVoxelEntries = scene->localVBA.lastFreeBlockId;
	allocationTempData_host->noAllocatedExcessEntries = scene->index.GetLastFreeExcessListId();
	allocationTempData_host->noVisibleEntries = 0;
	allocationTempData.UpdateDeviceFromHost();

	if (gridSizeVS.x > 0) {
		setToType3 << < gridSizeVS, cudaBlockSizeVS >> > (hashBlockVisibilityTypes_device,
				visibleEntryIDs_device, renderState_vh->noVisibleEntries);
		ORcudaKernelCheck;
	}

	bool useSwapping = scene->globalCache != nullptr;
	do {
		this->sourceSceneHashBlockStates->Clear(NEEDS_NO_CHANGE);
		*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
		collisionDetected.UpdateDeviceFromHost();


		buildHashAllocAndVisibleType_device << < gridSizeHV, cudaBlockSizeHV >> > (entryAllocationTypes_device,
				hashBlockVisibilityTypes_device,
				allocationBlockCoordinates_device, depth, invM_d, invProjParams_d, mu, depthImgSize, oneOverHashEntrySize, hashTable,
				scene->sceneParams->viewFrustum_min, scene->sceneParams->viewFrustum_max,
				collisionDetected.GetData(MEMORYDEVICE_CUDA));
		ORcudaKernelCheck;

		if (onlyUpdateVisibleList) {
			useSwapping = false;
			*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
			collisionDetected.UpdateDeviceFromHost();
		} else {
			allocateHashedVoxelBlocksUsingLists_SetVisibility_device << < gridSizeAL, cudaBlockSizeAL >> > (
					voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
							hashTable, noTotalEntries, entryAllocationTypes_device,
							allocationBlockCoordinates_device, hashBlockVisibilityTypes_device);
			ORcudaKernelCheck;
		}
		collisionDetected.UpdateHostFromDevice();
	} while (*collisionDetected.GetData(MEMORYDEVICE_CPU));

	if (useSwapping) {
		buildVisibleList_device<true> << < gridSizeAL, cudaBlockSizeAL >> >
		                                               (hashTable, swapStates, noTotalEntries, visibleEntryIDs_device,
				                                               allocationTempData.GetData(
						                                               MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device, M_d, projParams_d, depthImgSize, voxelSize);
		ORcudaKernelCheck;
	} else {
		buildVisibleList_device<false> << < gridSizeAL, cudaBlockSizeAL >> >
		                                                (hashTable, swapStates, noTotalEntries, visibleEntryIDs_device,
				                                                allocationTempData.GetData(
						                                                MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device, M_d, projParams_d, depthImgSize, voxelSize);
		ORcudaKernelCheck;
	}

	if (useSwapping) {
		reAllocateSwappedOutVoxelBlocks_device << < gridSizeAL, cudaBlockSizeAL >> >
		                                                        (voxelAllocationList, hashTable, noTotalEntries,
				                                                        allocationTempData.GetData(
						                                                        MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device);
		ORcudaKernelCheck;
	}

	allocationTempData.UpdateHostFromDevice();
	renderState_vh->noVisibleEntries = allocationTempData_host->noVisibleEntries;
	scene->localVBA.lastFreeBlockId = allocationTempData_host->noAllocatedVoxelEntries;
	scene->index.SetLastFreeExcessListId(allocationTempData_host->noAllocatedExcessEntries);

}

template<typename TVoxel, typename TWarp>
void ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::AllocateTSDFVolumeFromTSDFVolume(
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* targetVolume,
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* sourceVolume) {
	AllocateFromVolumeGeneric(targetVolume, sourceVolume);
}

template<typename TVoxel, typename TWarp>
void ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::AllocateWarpVolumeFromTSDFVolume(
		ITMVoxelVolume<TWarp, ITMVoxelBlockHash>* targetVolume,
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* sourceVolume) {
	AllocateFromVolumeGeneric(targetVolume, sourceVolume);
}

template<typename TVoxel, typename TWarp>
template<WarpType TWarpType>
void ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::AllocateFromWarpedVolume(
		ITMVoxelVolume<TWarp, ITMVoxelBlockHash>* warpField, ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* sourceTSDF,
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* targetTSDF) {
	DIEWITHEXCEPTION_REPORTLOCATION("Not implemented!");
}

template<typename TVoxel, typename TWarp>
template<typename TVoxelTarget, typename TVoxelSource>
void ITMHashAllocationEngine_CUDA<TVoxel, TWarp>::AllocateFromVolumeGeneric(
		ITMVoxelVolume<TVoxelTarget, ITMVoxelBlockHash>* targetVolume,
		ITMVoxelVolume<TVoxelSource, ITMVoxelBlockHash>* sourceVolume) {

	ITMHashEntry* targetHashTable = targetVolume->index.getIndexData();
	ITMHashEntry* sourceHashTable = sourceVolume->index.getIndexData();
	int* voxelAllocationList = targetVolume->localVBA.GetAllocationList();
	int* excessAllocationList = targetVolume->index.GetExcessAllocationList();
	int hashEntryCount = targetVolume->index.noTotalEntries;

	uchar* entryAllocationTypes_device = this->targetSceneHashBlockStates->GetData(MEMORYDEVICE_CUDA);
	Vector3s* allocationBlockCoordinates_device = this->targetSceneHashBlockCoordinates->GetData(MEMORYDEVICE_CUDA);

	ORUtils::MemoryBlock<bool> collisionDetected(1, true, true);

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->noAllocatedVoxelEntries = targetVolume->localVBA.lastFreeBlockId;
	allocationTempData_host->noAllocatedExcessEntries = targetVolume->index.GetLastFreeExcessListId();
	allocationTempData_host->noVisibleEntries = 0;
	allocationTempData.UpdateDeviceFromHost();

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	do {
		this->targetSceneHashBlockStates->Clear(NEEDS_NO_CHANGE);
		*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
		collisionDetected.UpdateDeviceFromHost();

		buildHashAllocationTypeList_VolumeToVolume << < gridSizeAL, cudaBlockSizeAL >> > (
				entryAllocationTypes_device, allocationBlockCoordinates_device, targetHashTable, sourceHashTable,
						hashEntryCount, collisionDetected.GetData(MEMORYDEVICE_CUDA));

		allocateHashedVoxelBlocksUsingLists_device << < gridSizeAL, cudaBlockSizeAL >> > (
				voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
						targetHashTable, hashEntryCount, entryAllocationTypes_device,
						allocationBlockCoordinates_device);
		ORcudaKernelCheck;
		collisionDetected.UpdateHostFromDevice();
	} while (*collisionDetected.GetData(MEMORYDEVICE_CPU));
}
