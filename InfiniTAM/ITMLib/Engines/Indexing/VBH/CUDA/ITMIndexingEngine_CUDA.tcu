//  ================================================================
//  Created by Gregory Kramida on 11/1/19.
//  Copyright (c) 2019 Gregory Kramida
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at

//  http://www.apache.org/licenses/LICENSE-2.0

//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//  ================================================================
#pragma once

#include "ITMIndexingEngine_CUDA.h"
#include "../../../../Objects/RenderStates/ITMRenderState_VH.h"
#include "../../Shared/ITMIndexingEngine_Shared.h"
#include "ITMIndexingEngine_CUDA_Kernels.h"


using namespace ITMLib;


template<typename TVoxel>
void ITMIndexingEngine<TVoxel, ITMVoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateFromDepth(
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* scene,
		const ITMView* view, const ITMTrackingState* trackingState, const ITMRenderState* renderState,
		bool onlyUpdateVisibleList, bool resetVisibleList) {

	Vector2i depthImgSize = view->depth->noDims;
	float voxelSize = scene->sceneParams->voxelSize;

	Matrix4f M_d, invM_d;
	Vector4f projParams_d, invProjParams_d;

	ITMRenderState_VH* renderState_vh = (ITMRenderState_VH*) renderState;
	if (resetVisibleList) renderState_vh->noVisibleEntries = 0;

	M_d = trackingState->pose_d->GetM();
	M_d.inv(invM_d);

	projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
	invProjParams_d = projParams_d;
	invProjParams_d.x = 1.0f / invProjParams_d.x;
	invProjParams_d.y = 1.0f / invProjParams_d.y;

	float mu = scene->sceneParams->mu;

	float* depth = view->depth->GetData(MEMORYDEVICE_CUDA);
	int* voxelAllocationList = scene->localVBA.GetAllocationList();
	int* excessAllocationList = scene->index.GetExcessAllocationList();
	ITMHashEntry* hashTable = scene->index.GetEntries();
	ITMHashSwapState* swapStates = scene->Swapping() ? scene->globalCache->GetSwapStates(true) : 0;

	ITMLib::HashEntryState* hashEntryStates_device = scene->index.GetHashEntryStates();
	Vector3s* allocationBlockCoordinates_device = scene->index.GetAllocationBlockCoordinates();

	int noTotalEntries = scene->index.hashEntryCount;

	int* visibleEntryIDs_device = renderState_vh->GetVisibleEntryIDs();
	uchar* hashBlockVisibilityTypes_device = renderState_vh->GetEntriesVisibleType();

	dim3 cudaBlockSizeHV(16, 16);
	dim3 gridSizeHV((int) ceil((float) depthImgSize.x / (float) cudaBlockSizeHV.x),
	                (int) ceil((float) depthImgSize.y / (float) cudaBlockSizeHV.y));

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) noTotalEntries / (float) cudaBlockSizeAL.x));

	dim3 cudaBlockSizeVS(256, 1);
	dim3 gridSizeVS((int) ceil((float) renderState_vh->noVisibleEntries / (float) cudaBlockSizeVS.x));

	float oneOverHashEntrySize = 1.0f / (voxelSize * VOXEL_BLOCK_SIZE);//m

	ORUtils::MemoryBlock<bool> collisionDetected(1, true, true);

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->noAllocatedVoxelEntries = scene->localVBA.lastFreeBlockId;
	allocationTempData_host->noAllocatedExcessEntries = scene->index.GetLastFreeExcessListId();
	allocationTempData_host->noVisibleEntries = 0;
	allocationTempData.UpdateDeviceFromHost();

	if (gridSizeVS.x > 0) {
		setToType3 << < gridSizeVS, cudaBlockSizeVS >> > (hashBlockVisibilityTypes_device,
				visibleEntryIDs_device, renderState_vh->noVisibleEntries);
		ORcudaKernelCheck;
	}

	bool useSwapping = scene->globalCache != nullptr;
	do {
		scene->index.ClearHashEntryStates();
		*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
		collisionDetected.UpdateDeviceFromHost();


		buildHashAllocAndVisibleType_device << < gridSizeHV, cudaBlockSizeHV >> > (hashEntryStates_device,
				hashBlockVisibilityTypes_device,
				allocationBlockCoordinates_device, depth, invM_d, invProjParams_d, mu, depthImgSize, oneOverHashEntrySize, hashTable,
				scene->sceneParams->viewFrustum_min, scene->sceneParams->viewFrustum_max,
				collisionDetected.GetData(MEMORYDEVICE_CUDA));
		ORcudaKernelCheck;

		if (onlyUpdateVisibleList) {
			useSwapping = false;
			*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
			collisionDetected.UpdateDeviceFromHost();
		} else {
			allocateHashedVoxelBlocksUsingLists_SetVisibility_device << < gridSizeAL, cudaBlockSizeAL >> > (
					voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
							hashTable, noTotalEntries, hashEntryStates_device,
							allocationBlockCoordinates_device, hashBlockVisibilityTypes_device);
			ORcudaKernelCheck;
		}
		collisionDetected.UpdateHostFromDevice();
	} while (*collisionDetected.GetData(MEMORYDEVICE_CPU));

	if (useSwapping) {
		buildVisibleList_device<true> << < gridSizeAL, cudaBlockSizeAL >> >
		(hashTable, swapStates, noTotalEntries, visibleEntryIDs_device,
				allocationTempData.GetData(
						MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device, M_d, projParams_d, depthImgSize, voxelSize);
		ORcudaKernelCheck;
	} else {
		buildVisibleList_device<false> << < gridSizeAL, cudaBlockSizeAL >> >
		(hashTable, swapStates, noTotalEntries, visibleEntryIDs_device,
				allocationTempData.GetData(
						MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device, M_d, projParams_d, depthImgSize, voxelSize);
		ORcudaKernelCheck;
	}

	if (useSwapping) {
		reAllocateSwappedOutVoxelBlocks_device << < gridSizeAL, cudaBlockSizeAL >> >
		                                                        (voxelAllocationList, hashTable, noTotalEntries,
				                                                        allocationTempData.GetData(
						                                                        MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device);
		ORcudaKernelCheck;
	}

	allocationTempData.UpdateHostFromDevice();
	renderState_vh->noVisibleEntries = allocationTempData_host->noVisibleEntries;
	scene->localVBA.lastFreeBlockId = allocationTempData_host->noAllocatedVoxelEntries;
	scene->index.SetLastFreeExcessListId(allocationTempData_host->noAllocatedExcessEntries);

}



template<typename TVoxel>
template<typename TVoxelATarget, typename TVoxelASource>
void ITMIndexingEngine<TVoxel, ITMVoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateUsingOtherVolume(
		ITMVoxelVolume<TVoxelATarget, ITMVoxelBlockHash>* targetVolume,
		ITMVoxelVolume<TVoxelASource, ITMVoxelBlockHash>* sourceVolume) {

	assert(targetVolume->index.hashEntryCount == sourceVolume->index.hashEntryCount);

	ITMHashEntry* targetHashTable = targetVolume->index.GetIndexData();
	ITMHashEntry* sourceHashTable = sourceVolume->index.GetIndexData();
	int* voxelAllocationList = targetVolume->localVBA.GetAllocationList();
	int* excessAllocationList = targetVolume->index.GetExcessAllocationList();
	int hashEntryCount = targetVolume->index.hashEntryCount;

	HashEntryState* hashEntryStates_device = targetVolume->index.GetHashEntryStates();
	Vector3s* blockCoordinates_device = targetVolume->index.GetAllocationBlockCoordinates();

	ORUtils::MemoryBlock<bool> collisionDetected(1, true, true);

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->noAllocatedVoxelEntries = targetVolume->localVBA.lastFreeBlockId;
	allocationTempData_host->noAllocatedExcessEntries = targetVolume->index.GetLastFreeExcessListId();
	allocationTempData_host->noVisibleEntries = 0;
	allocationTempData.UpdateDeviceFromHost();

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	do {
		targetVolume->index.ClearHashEntryStates();
		*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
		collisionDetected.UpdateDeviceFromHost();

		buildHashAllocationTypeList_VolumeToVolume << < gridSizeAL, cudaBlockSizeAL >> > (
				hashEntryStates_device, blockCoordinates_device, targetHashTable, sourceHashTable,
						hashEntryCount, collisionDetected.GetData(MEMORYDEVICE_CUDA));

		allocateHashedVoxelBlocksUsingLists_device << < gridSizeAL, cudaBlockSizeAL >> > (
				voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
						targetHashTable, hashEntryCount, hashEntryStates_device,
						blockCoordinates_device);
		ORcudaKernelCheck;
		collisionDetected.UpdateHostFromDevice();
	} while (*collisionDetected.GetData(MEMORYDEVICE_CPU));
}

template<typename TVoxel>
void ITMIndexingEngine<TVoxel, ITMVoxelBlockHash, MEMORYDEVICE_CUDA>::
AllocateHashEntriesUsingLists(
		ITMVoxelVolume<TVoxel, ITMVoxelBlockHash>* scene,
		const HashEntryState* hashEntryStates_device,
		Vector3s* blockCoordinates_device) {

	const int hashEntryCount = scene->index.hashEntryCount;

	int* voxelAllocationList = scene->localVBA.GetAllocationList();
	int* excessAllocationList = scene->index.GetExcessAllocationList();
	ITMHashEntry* hashTable = scene->index.GetIndexData();

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->noAllocatedVoxelEntries = scene->localVBA.lastFreeBlockId;
	allocationTempData_host->noAllocatedExcessEntries = scene->index.GetLastFreeExcessListId();
	allocationTempData_host->noVisibleEntries = 0;
	allocationTempData.UpdateDeviceFromHost();

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	allocateHashedVoxelBlocksUsingLists_device << < gridSizeAL, cudaBlockSizeAL >> > (
			voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
					hashTable, hashEntryCount, hashEntryStates_device,
					blockCoordinates_device);
}


template<typename TVoxelA>
void ITMIndexingEngine<TVoxelA, ITMVoxelBlockHash, MEMORYDEVICE_CUDA>::
AllocateHashEntriesUsingLists_SetVisibility(ITMVoxelVolume<TVoxelA, ITMVoxelBlockHash>* scene,
                                            const ITMLib::HashEntryState* hashEntryStates_device,
                                            Vector3s* blockCoordinates_device,
                                            uchar* hashBlockVisibilityTypes_device) {


	const int hashEntryCount = scene->index.hashEntryCount;

	int* voxelAllocationList = scene->localVBA.GetAllocationList();
	int* excessAllocationList = scene->index.GetExcessAllocationList();
	ITMHashEntry* hashTable = scene->index.GetIndexData();

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->noAllocatedVoxelEntries = scene->localVBA.lastFreeBlockId;
	allocationTempData_host->noAllocatedExcessEntries = scene->index.GetLastFreeExcessListId();
	allocationTempData_host->noVisibleEntries = 0;
	allocationTempData.UpdateDeviceFromHost();

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	allocateHashedVoxelBlocksUsingLists_SetVisibility_device << < gridSizeAL, cudaBlockSizeAL >> > (
			voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
					hashTable, hashEntryCount, hashEntryStates_device,
					blockCoordinates_device, hashBlockVisibilityTypes_device);
}
