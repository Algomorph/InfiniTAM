// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#include "VisualizationEngine_CUDA.h"
#include "VisualizationHelpers_CUDA.h"

using namespace ITMLib;

inline dim3 getGridSize(dim3 taskSize, dim3 blockSize)
{
	return dim3((taskSize.x + blockSize.x - 1) / blockSize.x, (taskSize.y + blockSize.y - 1) / blockSize.y, (taskSize.z + blockSize.z - 1) / blockSize.z);
}

inline dim3 getGridSize(Vector2i taskSize, dim3 blockSize) { return getGridSize(dim3(taskSize.x, taskSize.y), blockSize); }

template<class TVoxel, class TIndex>
VisualizationEngine_CUDA<TVoxel, TIndex>::VisualizationEngine_CUDA()
{
	ORcudaSafeCall(cudaMalloc((void**)&noTotalPoints_device, sizeof(uint)));
}

template<class TVoxel, class TIndex>
VisualizationEngine_CUDA<TVoxel, TIndex>::~VisualizationEngine_CUDA()
{
	ORcudaSafeCall(cudaFree(noTotalPoints_device));
}

template<class TVoxel>
VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::VisualizationEngine_CUDA()
{
	ORcudaSafeCall(cudaMalloc((void**)&rendering_block_list_device, sizeof(RenderingBlock) * MAX_RENDERING_BLOCKS));
	ORcudaSafeCall(cudaMalloc((void**)&block_count_device, sizeof(int)));
	ORcudaSafeCall(cudaMalloc((void**)&noTotalPoints_device, sizeof(uint)));
	ORcudaSafeCall(cudaMalloc((void**)&visible_block_count_device, sizeof(int)));
}

template<class TVoxel>
VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::~VisualizationEngine_CUDA() {
	ORcudaSafeCall(cudaFree(noTotalPoints_device));
	ORcudaSafeCall(cudaFree(block_count_device));
	ORcudaSafeCall(cudaFree(rendering_block_list_device));
	ORcudaSafeCall(cudaFree(visible_block_count_device));
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::FindVisibleBlocks(VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, RenderState *renderState) const
{
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::FindVisibleBlocks(VoxelVolume<TVoxel,VoxelBlockHash> *volume, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, RenderState *renderState) const
{
	const HashEntry *hash_table = volume->index.GetEntries();
	int hash_entry_count = volume->index.hash_entry_count;
	float voxel_size = volume->GetParameters().voxel_size;
	Vector2i imgSize = renderState->renderingRangeImage->dimensions;

	Matrix4f M = pose->GetM();
	Vector4f projParams = intrinsics->projectionParamsSimple.all;

	ORcudaSafeCall(cudaMemset(visible_block_count_device, 0, sizeof(int)));

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int)ceil((float)hash_entry_count / (float)cudaBlockSizeAL.x));
	buildCompleteVisibleList_device <<<gridSizeAL, cudaBlockSizeAL >>>(
			hash_table, hash_entry_count, volume->index.GetVisibleBlockHashCodes(), visible_block_count_device,
			volume->index.GetBlockVisibilityTypes(), M, projParams, imgSize, voxel_size);
	ORcudaKernelCheck;

	int visible_hash_block_count_CPU;
	ORcudaSafeCall(cudaMemcpy(&visible_hash_block_count_CPU, visible_block_count_device, sizeof(int), cudaMemcpyDeviceToHost));
	volume->index.SetVisibleBlockCount(visible_hash_block_count_CPU);
}

template<class TVoxel, class TIndex>
int VisualizationEngine_CUDA<TVoxel, TIndex>::CountVisibleBlocks(const VoxelVolume<TVoxel,TIndex> *scene, const RenderState *renderState, int minBlockId, int maxBlockId) const
{
	return 1;
}

template<class TVoxel>
int VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CountVisibleBlocks(const VoxelVolume<TVoxel,VoxelBlockHash> *volume, const RenderState *renderState, int minBlockId, int maxBlockId) const
{
	int visible_block_count = volume->index.GetVisibleBlockCount();
	const int *visible_block_hash_codes_device = volume->index.GetVisibleBlockHashCodes();

	ORcudaSafeCall(cudaMemset(block_count_device, 0, sizeof(uint)));

	dim3 blockSize(256);
	dim3 gridSize((int)ceil((float)visible_block_count / (float)blockSize.x));

	const HashEntry* hash_table_device = volume->index.GetEntries();
	countVisibleBlocks_device<<<gridSize,blockSize>>>(visible_block_hash_codes_device, visible_block_count, hash_table_device, block_count_device, minBlockId, maxBlockId);
	ORcudaKernelCheck;

	uint visible_block_count_CPU;
	ORcudaSafeCall(cudaMemcpy(&visible_block_count_CPU, block_count_device, sizeof(uint), cudaMemcpyDeviceToHost));

	return visible_block_count_CPU;
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::CreateExpectedDepths(const VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose,
                                                                    const Intrinsics *intrinsics, RenderState *renderState) const
{
	Vector2f *minmaxData = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);

	Vector2f init;
	//TODO : this could be improved a bit...
	init.x = 0.2f; init.y = 3.0f;
	memsetKernel<Vector2f>(minmaxData, init, renderState->renderingRangeImage->size());
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CreateExpectedDepths(const VoxelVolume<TVoxel,VoxelBlockHash> *volume, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics,
                                                                            RenderState *renderState) const
{
	float voxelSize = volume->GetParameters().voxel_size;

	Vector2i imgSize = renderState->renderingRangeImage->dimensions;
	Vector2f *minmaxData = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);

	Vector2f init;
	init.x = FAR_AWAY; init.y = VERY_CLOSE;
	memsetKernel<Vector2f>(minmaxData, init, renderState->renderingRangeImage->size());

	//go through list of visible 8x8x8 blocks
	{
		const HashEntry* hash_entries = volume->index.GetEntries();
		const int* visible_block_hash_codes = volume->index.GetUtilizedBlockHashCodes();
		int visible_block_count = volume->index.GetUtilizedBlockCount();
		if (visible_block_count == 0) return;

		dim3 cuda_block_size(256);
		dim3 cuda_grid_size(ceil_of_integer_quotient(visible_block_count, cuda_block_size.x));
		ORcudaSafeCall(cudaMemset(block_count_device, 0, sizeof(uint)));
		projectAndSplitBlocks_device <<<cuda_grid_size, cuda_block_size >>>(hash_entries, visible_block_hash_codes, visible_block_count, pose->GetM(),
			intrinsics->projectionParamsSimple.all, imgSize, voxelSize, rendering_block_list_device, block_count_device);
		ORcudaKernelCheck;
	}

	uint total_block_count;
	ORcudaSafeCall(cudaMemcpy(&total_block_count, block_count_device, sizeof(uint), cudaMemcpyDeviceToHost));
	if (total_block_count == 0) return;
	if (total_block_count > (unsigned)MAX_RENDERING_BLOCKS) total_block_count = MAX_RENDERING_BLOCKS;

	// go through rendering blocks
	{
		// fill minmaxData
		dim3 blockSize(16, 16);
		dim3 gridSize((unsigned int)ceil((float)total_block_count / 4.0f), 4);
		fillBlocks_device <<<gridSize, blockSize >>>(total_block_count, rendering_block_list_device, imgSize, minmaxData);
		ORcudaKernelCheck;
	}
}

template<typename TIndex> static inline HashBlockVisibility* GetBlockVisibilityTypes(TIndex& index);
template<> inline HashBlockVisibility* GetBlockVisibilityTypes<VoxelBlockHash>(VoxelBlockHash& index){
	return index.GetBlockVisibilityTypes();
}
template<> inline HashBlockVisibility* GetBlockVisibilityTypes<PlainVoxelArray>(PlainVoxelArray& index){
	return nullptr;
}

template <class TVoxel, class TIndex>
static void GenericRaycast(VoxelVolume<TVoxel, TIndex>* volume, const Vector2i& depth_image_size, const Matrix4f& depth_camera_inverse_pose, const Vector4f& depth_camera_projection_parameters, const RenderState* render_state, bool update_visible_list)
{
	float voxel_size = volume->GetParameters().voxel_size;
	float voxel_size_reciprocal = 1.0f / voxel_size;

	HashBlockVisibility* block_visibility_types = GetBlockVisibilityTypes(volume->index);

	dim3 cuda_block_size(16, 12);
	dim3 cuda_grid_size(ceil_of_integer_quotient(depth_image_size.x, cuda_block_size.x), ceil_of_integer_quotient(depth_image_size.y, cuda_block_size.y));
	if (update_visible_list && block_visibility_types != nullptr) genericRaycast_device<TVoxel, TIndex, true> <<< cuda_grid_size, cuda_block_size >>> (
				render_state->raycastResult->GetData(MEMORYDEVICE_CUDA),
				block_visibility_types,
				volume->GetVoxels(),
				volume->index.GetIndexData(),
				depth_image_size,
				depth_camera_inverse_pose,
				InvertProjectionParams(depth_camera_projection_parameters),
				voxel_size_reciprocal,
				render_state->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
				volume->GetParameters().truncation_distance
		);
	else genericRaycast_device<TVoxel, TIndex, false> <<<cuda_grid_size, cuda_block_size >>>(
				render_state->raycastResult->GetData(MEMORYDEVICE_CUDA),
				nullptr,
				volume->GetVoxels(),
				volume->index.GetIndexData(),
				depth_image_size,
				depth_camera_inverse_pose,
				InvertProjectionParams(depth_camera_projection_parameters),
				voxel_size_reciprocal,
				render_state->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
				volume->GetParameters().truncation_distance
		);
	ORcudaKernelCheck;
}

template<class TVoxel, class TIndex>
static void RenderImage_common(VoxelVolume<TVoxel, TIndex> *volume, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, const RenderState *renderState,
                               UChar4Image *outputImage, IRenderingEngine::RenderImageType type, IRenderingEngine::RenderRaycastSelection raycastType)
{
	Vector2i imgSize = outputImage->dimensions;
	Matrix4f invM = pose->GetInvM();

	Vector4f *pointsRay;
	if (raycastType == IRenderingEngine::RENDER_FROM_OLD_RAYCAST) {
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	} else if (raycastType == IRenderingEngine::RENDER_FROM_OLD_FORWARDPROJ) {
		pointsRay = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	} else {
		GenericRaycast(volume, imgSize, invM, intrinsics->projectionParamsSimple.all, renderState, false);
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	}

	Vector3f lightSource = -Vector3f(invM.getColumn(2));

	Vector4u *outRendering = outputImage->GetData(MEMORYDEVICE_CUDA);

	dim3 cudaBlockSize(8, 8);
	dim3 gridSize((int)ceil((float)imgSize.x / (float)cudaBlockSize.x), (int)ceil((float)imgSize.y / (float)cudaBlockSize.y));

	if ((type == IRenderingEngine::RENDER_COLOUR_FROM_VOLUME) &&
	    (!TVoxel::hasColorInformation)) type = IRenderingEngine::RENDER_SHADED_GREYSCALE;

	switch (type) {
	case IRenderingEngine::RENDER_COLOUR_FROM_VOLUME:
		renderColour_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, volume->GetVoxels(),
		                                                                  volume->index.GetIndexData(), imgSize);
		ORcudaKernelCheck;
		break;
	case IRenderingEngine::RENDER_COLOUR_FROM_NORMAL:
		renderColourFromNormal_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay,
		                                                                            volume->GetVoxels(),
		                                                                            volume->index.GetIndexData(), imgSize, lightSource);
		ORcudaKernelCheck;
		break;
	case IRenderingEngine::RENDER_COLOUR_FROM_CONFIDENCE:
		renderColourFromConfidence_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay,
		                                                                                volume->GetVoxels(),
		                                                                                volume->index.GetIndexData(), imgSize, lightSource);
		ORcudaKernelCheck;
		break;
	case IRenderingEngine::RENDER_SHADED_GREYSCALE_IMAGENORMALS:
		if (intrinsics->FocalLengthSignsDiffer())
		{
			renderGrey_ImageNormals_device<true> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, volume->GetParameters().voxel_size,
			                                                                   imgSize, lightSource);
		}
		else
		{
			renderGrey_ImageNormals_device<false> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, volume->GetParameters().voxel_size,
			                                                                    imgSize, lightSource);
		}
		ORcudaKernelCheck;
		break;
	case IRenderingEngine::RENDER_SHADED_GREYSCALE:
	default:
		renderGrey_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, volume->GetVoxels(),
		                                                                volume->index.GetIndexData(), imgSize, lightSource);
		ORcudaKernelCheck;
		break;
	}
}

template<class TVoxel, class TIndex>
static void CreatePointCloud_common(VoxelVolume<TVoxel, TIndex>* volume, const View*view, CameraTrackingState* camera_tracking_state, RenderState* render_state,
                                    bool skipPoints, uint* point_count)
{
	Vector2i raycast_image_dimensions = render_state->raycastResult->dimensions;
	Matrix4f inverted_rgb_camera_matrix = camera_tracking_state->pose_d->GetInvM() * view->calib.trafo_rgb_to_depth.calib;

	GenericRaycast(volume, raycast_image_dimensions, inverted_rgb_camera_matrix, view->calib.intrinsics_rgb.projectionParamsSimple.all, render_state, true);
	camera_tracking_state->pose_pointCloud->SetFrom(camera_tracking_state->pose_d);

	ORcudaSafeCall(cudaMemsetAsync(point_count, 0, sizeof(uint)));

	Vector3f light_source = -Vector3f(inverted_rgb_camera_matrix.getColumn(2));
	Vector4f* locations = camera_tracking_state->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f* colours = camera_tracking_state->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f* raycast_points = render_state->raycastResult->GetData(MEMORYDEVICE_CUDA);

	dim3 cuda_block_size(16, 16);
	dim3 cuda_grid_size = getGridSize(raycast_image_dimensions, cuda_block_size);
	renderPointCloud_device<TVoxel, TIndex> <<<cuda_grid_size, cuda_block_size >>>
			(locations, colours, point_count,
			 raycast_points, volume->GetVoxels(), volume->index.GetIndexData(), skipPoints, volume->GetParameters().voxel_size,
			 raycast_image_dimensions, light_source);
	ORcudaKernelCheck;

	ORcudaSafeCall(cudaMemcpy(&camera_tracking_state->pointCloud->noTotalPoints, point_count, sizeof(uint), cudaMemcpyDeviceToHost));
}

template<class TVoxel, class TIndex>
void
CreateICPMaps_common(VoxelVolume<TVoxel, TIndex>* volume, const View* view, CameraTrackingState* camera_tracking_state, RenderState* render_state) {
	Vector2i map_dimensions = render_state->raycastResult->dimensions;
	Matrix4f inverted_depth_camera_pose = camera_tracking_state->pose_d->GetInvM();

	GenericRaycast(volume, map_dimensions, inverted_depth_camera_pose, view->calib.intrinsics_d.projectionParamsSimple.all, render_state, true);
	camera_tracking_state->pose_pointCloud->SetFrom(camera_tracking_state->pose_d);

	Vector4f* pointsMap = camera_tracking_state->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f* normalsMap = camera_tracking_state->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f* pointsRay = render_state->raycastResult->GetData(MEMORYDEVICE_CUDA);
	Vector3f lightSource = -Vector3f(inverted_depth_camera_pose.getColumn(2));

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int) ceil((float) map_dimensions.x / (float) cudaBlockSize.x), (int) ceil((float) map_dimensions.y / (float) cudaBlockSize.y));

	if (view->calib.intrinsics_d.FocalLengthSignsDiffer()) {
		renderICP_device<true> <<<gridSize, cudaBlockSize>>>(pointsMap, normalsMap, pointsRay,
		                                                     volume->GetParameters().voxel_size, map_dimensions, lightSource);
	} else {
		renderICP_device<false> <<<gridSize, cudaBlockSize>>>(pointsMap, normalsMap, pointsRay,
		                                                      volume->GetParameters().voxel_size, map_dimensions, lightSource);
	}
	ORcudaKernelCheck;
}

template<class TVoxel, class TIndex>
static void ForwardRender_common(const VoxelVolume<TVoxel, TIndex> *volume, const View *view, CameraTrackingState *tracking_state, RenderState *render_state,
                                 uint *point_count)
{
	Vector2i imgSize = render_state->raycastResult->dimensions;
	Matrix4f M = tracking_state->pose_d->GetM();
	Matrix4f invM = tracking_state->pose_d->GetInvM();
	const Vector4f& depth_camera_projection_parameters = view->calib.intrinsics_d.projectionParamsSimple.all;

	const Vector4f* pointsRay = render_state->raycastResult->GetData(MEMORYDEVICE_CUDA);
	float* depth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f* forward_projected_points = render_state->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	int* missing_point_indices = render_state->fwdProjMissingPoints->GetData(MEMORYDEVICE_CUDA);
	const Vector2f* pixel_depth_range_data = render_state->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);
	float voxel_size_reciprocal = 1.0f / volume->GetParameters().voxel_size;
	float voxel_size = volume->GetParameters().voxel_size;
	const TVoxel* voxels = volume->GetVoxels();
	const typename TIndex::IndexData* index_data = volume->index.GetIndexData();

	render_state->forwardProjection->Clear();

	dim3 blockSize, gridSize;

	{ // forward projection
		blockSize = dim3(16, 16);
		gridSize = dim3((int) ceil((float) imgSize.x / (float) blockSize.x), (int) ceil((float) imgSize.y / (float) blockSize.y));

		forwardProject_device <<<gridSize, blockSize >>>(forward_projected_points, pointsRay, imgSize, M, depth_camera_projection_parameters, voxel_size);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(cudaMemset(point_count, 0, sizeof(uint)));

	{ // find missing points
		blockSize = dim3(16, 16);
		gridSize = dim3((int) ceil((float) imgSize.x / (float) blockSize.x), (int) ceil((float) imgSize.y / (float) blockSize.y));

		findMissingPoints_device <<<gridSize, blockSize >>>(missing_point_indices, point_count, pixel_depth_range_data,
		                                                    forward_projected_points, depth, imgSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(cudaMemcpy(&render_state->noFwdProjMissingPoints, point_count, sizeof(uint), cudaMemcpyDeviceToHost));

	{ // render missing points
		blockSize = dim3(256);
		gridSize = dim3((int) ceil((float) render_state->noFwdProjMissingPoints / blockSize.x));

		genericRaycastMissingPoints_device<TVoxel, TIndex, false> <<<gridSize, blockSize >>>(
				forward_projected_points, NULL, voxels, index_data, imgSize, invM,
				InvertProjectionParams(depth_camera_projection_parameters), voxel_size_reciprocal, missing_point_indices,
				render_state->noFwdProjMissingPoints, pixel_depth_range_data, volume->GetParameters().truncation_distance);
		ORcudaKernelCheck;
	}
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::RenderImage(VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, const RenderState *renderState,
                                                           UChar4Image *outputImage, IRenderingEngine::RenderImageType type,
                                                           IRenderingEngine::RenderRaycastSelection raycastType) const
{
	RenderImage_common(scene, pose, intrinsics, renderState, outputImage, type, raycastType);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::RenderImage(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics,
                                                                   const RenderState *renderState, UChar4Image *outputImage, IRenderingEngine::RenderImageType type,
                                                                   IRenderingEngine::RenderRaycastSelection raycastType) const
{
	RenderImage_common(scene, pose, intrinsics, renderState, outputImage, type, raycastType);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::FindSurface(VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, const RenderState *renderState) const
{
	GenericRaycast(scene, renderState->raycastResult->dimensions, pose->GetInvM(), intrinsics->projectionParamsSimple.all, renderState, false);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::FindSurface(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics,
                                                                   const RenderState *renderState) const
{
	GenericRaycast(scene, renderState->raycastResult->dimensions, pose->GetInvM(), intrinsics->projectionParamsSimple.all, renderState, false);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::CreatePointCloud(VoxelVolume<TVoxel,TIndex> *scene, const View *view, CameraTrackingState *trackingState, RenderState *renderState) const
{
	CreatePointCloud_common(scene, view, trackingState, renderState, false, noTotalPoints_device);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CreatePointCloud(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const View *view, CameraTrackingState *trackingState,
                                                                        RenderState *renderState) const
{
	CreatePointCloud_common(scene, view, trackingState, renderState, false, noTotalPoints_device);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::CreateICPMaps(VoxelVolume<TVoxel,TIndex> *scene, const View *view, CameraTrackingState *trackingState,
                                                             RenderState *renderState) const
{
	CreateICPMaps_common(scene, view, trackingState, renderState);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CreateICPMaps(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const View *view, CameraTrackingState *trackingState,
                                                                     RenderState *renderState) const
{
	CreateICPMaps_common(scene, view, trackingState, renderState);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::ForwardRender(const VoxelVolume<TVoxel,TIndex> *scene, const View *view, CameraTrackingState *trackingState,
                                                             RenderState *renderState) const
{
	ForwardRender_common(scene, view, trackingState, renderState, this->noTotalPoints_device);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::ForwardRender(const VoxelVolume<TVoxel,VoxelBlockHash> *scene, const View *view, CameraTrackingState *trackingState,
                                                                     RenderState *renderState) const
{
	ForwardRender_common(scene, view, trackingState, renderState, this->noTotalPoints_device);
}
