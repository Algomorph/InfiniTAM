// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#include "VisualizationEngine_CUDA.h"
#include "VisualizationHelpers_CUDA.h"

using namespace ITMLib;

inline dim3 getGridSize(dim3 taskSize, dim3 blockSize)
{
	return dim3((taskSize.x + blockSize.x - 1) / blockSize.x, (taskSize.y + blockSize.y - 1) / blockSize.y, (taskSize.z + blockSize.z - 1) / blockSize.z);
}

inline dim3 getGridSize(Vector2i taskSize, dim3 blockSize) { return getGridSize(dim3(taskSize.x, taskSize.y), blockSize); }

template<class TVoxel, class TIndex>
VisualizationEngine_CUDA<TVoxel, TIndex>::VisualizationEngine_CUDA()
{
	ORcudaSafeCall(cudaMalloc((void**)&noTotalPoints_device, sizeof(uint)));
}

template<class TVoxel, class TIndex>
VisualizationEngine_CUDA<TVoxel, TIndex>::~VisualizationEngine_CUDA()
{
	ORcudaSafeCall(cudaFree(noTotalPoints_device));
}

template<class TVoxel>
VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::VisualizationEngine_CUDA()
{
	ORcudaSafeCall(cudaMalloc((void**)&rendering_block_list_device, sizeof(RenderingBlock) * MAX_RENDERING_BLOCKS));
	ORcudaSafeCall(cudaMalloc((void**)&block_count_device, sizeof(int)));
	ORcudaSafeCall(cudaMalloc((void**)&noTotalPoints_device, sizeof(uint)));
	ORcudaSafeCall(cudaMalloc((void**)&visible_block_count_device, sizeof(int)));
}

template<class TVoxel>
VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::~VisualizationEngine_CUDA() {
	ORcudaSafeCall(cudaFree(noTotalPoints_device));
	ORcudaSafeCall(cudaFree(block_count_device));
	ORcudaSafeCall(cudaFree(rendering_block_list_device));
	ORcudaSafeCall(cudaFree(visible_block_count_device));
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::FindVisibleBlocks(VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, RenderState *renderState) const
{
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::FindVisibleBlocks(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, RenderState *renderState) const
{
	const HashEntry *hash_table = scene->index.GetEntries();
	int hash_entry_count = scene->index.hash_entry_count;
	float voxel_size = scene->parameters->voxel_size;
	Vector2i imgSize = renderState->renderingRangeImage->noDims;

	Matrix4f M = pose->GetM();
	Vector4f projParams = intrinsics->projectionParamsSimple.all;

	ORcudaSafeCall(cudaMemset(visible_block_count_device, 0, sizeof(int)));

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int)ceil((float)hash_entry_count / (float)cudaBlockSizeAL.x));
	buildCompleteVisibleList_device << <gridSizeAL, cudaBlockSizeAL >> >(
			hash_table, /*cacheStates, this->scene->useSwapping,*/ hash_entry_count,
					scene->index.GetVisibleBlockHashCodes(), visible_block_count_device, scene->index.GetBlockVisibilityTypes(), M, projParams,
		imgSize, voxel_size);
	ORcudaKernelCheck;

	int visible_hash_block_count_CPU;
	ORcudaSafeCall(cudaMemcpy(&visible_hash_block_count_CPU, visible_block_count_device, sizeof(int), cudaMemcpyDeviceToHost));
	scene->index.SetVisibleHashBlockCount(visible_hash_block_count_CPU);
}

template<class TVoxel, class TIndex>
int VisualizationEngine_CUDA<TVoxel, TIndex>::CountVisibleBlocks(const VoxelVolume<TVoxel,TIndex> *scene, const RenderState *renderState, int minBlockId, int maxBlockId) const
{
	return 1;
}

template<class TVoxel>
int VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CountVisibleBlocks(const VoxelVolume<TVoxel,VoxelBlockHash> *scene, const RenderState *renderState, int minBlockId, int maxBlockId) const
{
	int visible_block_count = scene->index.GetVisibleHashBlockCount();
	const int *visible_block_hash_codes_device = scene->index.GetVisibleBlockHashCodes();

	ORcudaSafeCall(cudaMemset(block_count_device, 0, sizeof(uint)));

	dim3 blockSize(256);
	dim3 gridSize((int)ceil((float)visible_block_count / (float)blockSize.x));

	const HashEntry* hash_table_device = scene->index.GetEntries();
	countVisibleBlocks_device<<<gridSize,blockSize>>>(visible_block_hash_codes_device, visible_block_count, hash_table_device, block_count_device, minBlockId, maxBlockId);
	ORcudaKernelCheck;

	uint visible_block_count_CPU;
	ORcudaSafeCall(cudaMemcpy(&visible_block_count_CPU, block_count_device, sizeof(uint), cudaMemcpyDeviceToHost));

	return visible_block_count_CPU;
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::CreateExpectedDepths(const VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose,
                                                                    const Intrinsics *intrinsics, RenderState *renderState) const
{
	Vector2f *minmaxData = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);

	Vector2f init;
	//TODO : this could be improved a bit...
	init.x = 0.2f; init.y = 3.0f;
	memsetKernel<Vector2f>(minmaxData, init, renderState->renderingRangeImage->dataSize);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CreateExpectedDepths(const VoxelVolume<TVoxel,VoxelBlockHash> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics,
                                                                            RenderState *renderState) const
{
	float voxelSize = scene->parameters->voxel_size;

	Vector2i imgSize = renderState->renderingRangeImage->noDims;
	Vector2f *minmaxData = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);

	Vector2f init;
	init.x = FAR_AWAY; init.y = VERY_CLOSE;
	memsetKernel<Vector2f>(minmaxData, init, renderState->renderingRangeImage->dataSize);

	//go through list of visible 8x8x8 blocks
	{
		const HashEntry* hash_entries = scene->index.GetEntries();
		const int* visible_block_hash_codes = scene->index.GetUtilizedBlockHashCodes();
		int visible_block_count = scene->index.GetUtilizedHashBlockCount();
		if (visible_block_count == 0) return;

		dim3 blockSize(256);
		dim3 gridSize((int)ceil((float)visible_block_count / (float)blockSize.x));
		ORcudaSafeCall(cudaMemset(block_count_device, 0, sizeof(uint)));
		projectAndSplitBlocks_device << <gridSize, blockSize >> >(hash_entries, visible_block_hash_codes, visible_block_count, pose->GetM(),
			intrinsics->projectionParamsSimple.all, imgSize, voxelSize, rendering_block_list_device, block_count_device);
		ORcudaKernelCheck;
	}

	uint total_block_count;
	ORcudaSafeCall(cudaMemcpy(&total_block_count, block_count_device, sizeof(uint), cudaMemcpyDeviceToHost));
	if (total_block_count == 0) return;
	if (total_block_count > (unsigned)MAX_RENDERING_BLOCKS) total_block_count = MAX_RENDERING_BLOCKS;

	// go through rendering blocks
	{
		// fill minmaxData
		dim3 blockSize(16, 16);
		dim3 gridSize((unsigned int)ceil((float)total_block_count / 4.0f), 4);
		fillBlocks_device << <gridSize, blockSize >> >(total_block_count, rendering_block_list_device, imgSize, minmaxData);
		ORcudaKernelCheck;
	}
}

template<typename TIndex> static inline HashBlockVisibility* GetBlockVisibilityTypes(TIndex& index);
template<> inline HashBlockVisibility* GetBlockVisibilityTypes<VoxelBlockHash>(VoxelBlockHash& index){
	return index.GetBlockVisibilityTypes();
}
template<> inline HashBlockVisibility* GetBlockVisibilityTypes<PlainVoxelArray>(PlainVoxelArray& index){
	return nullptr;
}

template <class TVoxel, class TIndex>
static void GenericRaycast(VoxelVolume<TVoxel, TIndex> *scene, const Vector2i& imgSize, const Matrix4f& invM, const Vector4f& projParams, const RenderState *renderState, bool updateVisibleList)
{
	float voxelSize = scene->parameters->voxel_size;
	float oneOverVoxelSize = 1.0f / voxelSize;

	HashBlockVisibility* blockVisibilityTypes = GetBlockVisibilityTypes(scene->index);

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int)ceil((float)imgSize.x / (float)cudaBlockSize.x), (int)ceil((float)imgSize.y / (float)cudaBlockSize.y));
	if (blockVisibilityTypes != nullptr) genericRaycast_device<TVoxel, TIndex, true> << < gridSize, cudaBlockSize >> > (
			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
			blockVisibilityTypes,
			scene->voxels.GetVoxelBlocks(),
			scene->index.GetIndexData(),
			imgSize,
			invM,
			InvertProjectionParams(projParams),
			oneOverVoxelSize,
			renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
			scene->parameters->narrow_band_half_width
		);
	else genericRaycast_device<TVoxel, TIndex, false> << <gridSize, cudaBlockSize >> >(
			renderState->raycastResult->GetData(MEMORYDEVICE_CUDA),
					nullptr,
			scene->voxels.GetVoxelBlocks(),
			scene->index.GetIndexData(),
			imgSize,
			invM,
			InvertProjectionParams(projParams),
			oneOverVoxelSize,
			renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA),
			scene->parameters->narrow_band_half_width
		);
	ORcudaKernelCheck;
}

template<class TVoxel, class TIndex>
static void RenderImage_common(VoxelVolume<TVoxel, TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, const RenderState *renderState,
                               ITMUChar4Image *outputImage, IVisualizationEngine::RenderImageType type, IVisualizationEngine::RenderRaycastSelection raycastType)
{
	Vector2i imgSize = outputImage->noDims;
	Matrix4f invM = pose->GetInvM();

	Vector4f *pointsRay;
	if (raycastType == IVisualizationEngine::RENDER_FROM_OLD_RAYCAST) {
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	} else if (raycastType == IVisualizationEngine::RENDER_FROM_OLD_FORWARDPROJ) {
		pointsRay = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	} else {
		GenericRaycast(scene, imgSize, invM, intrinsics->projectionParamsSimple.all, renderState, false);
		pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	}

	Vector3f lightSource = -Vector3f(invM.getColumn(2));

	Vector4u *outRendering = outputImage->GetData(MEMORYDEVICE_CUDA);

	dim3 cudaBlockSize(8, 8);
	dim3 gridSize((int)ceil((float)imgSize.x / (float)cudaBlockSize.x), (int)ceil((float)imgSize.y / (float)cudaBlockSize.y));

	if ((type == IVisualizationEngine::RENDER_COLOUR_FROM_VOLUME)&&
	    (!TVoxel::hasColorInformation)) type = IVisualizationEngine::RENDER_SHADED_GREYSCALE;

	switch (type) {
	case IVisualizationEngine::RENDER_COLOUR_FROM_VOLUME:
		renderColour_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, scene->voxels.GetVoxelBlocks(),
			scene->index.GetIndexData(), imgSize);
		ORcudaKernelCheck;
		break;
	case IVisualizationEngine::RENDER_COLOUR_FROM_NORMAL:
		renderColourFromNormal_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, scene->voxels.GetVoxelBlocks(),
			scene->index.GetIndexData(), imgSize, lightSource);
		ORcudaKernelCheck;
		break;
	case IVisualizationEngine::RENDER_COLOUR_FROM_CONFIDENCE:
		renderColourFromConfidence_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, scene->voxels.GetVoxelBlocks(),
			scene->index.GetIndexData(), imgSize, lightSource);
		ORcudaKernelCheck;
		break;
	case IVisualizationEngine::RENDER_SHADED_GREYSCALE_IMAGENORMALS:
		if (intrinsics->FocalLengthSignsDiffer())
		{
			renderGrey_ImageNormals_device<true> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, scene->parameters->voxel_size,
				imgSize, lightSource);
		}
		else
		{
			renderGrey_ImageNormals_device<false> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, scene->parameters->voxel_size,
				imgSize, lightSource);
		}
		ORcudaKernelCheck;
		break;
	case IVisualizationEngine::RENDER_SHADED_GREYSCALE:
	default:
		renderGrey_device<TVoxel, TIndex> <<<gridSize, cudaBlockSize>>>(outRendering, pointsRay, scene->voxels.GetVoxelBlocks(),
			scene->index.GetIndexData(), imgSize, lightSource);
		ORcudaKernelCheck;
		break;
	}
}

template<class TVoxel, class TIndex>
static void CreatePointCloud_common(VoxelVolume<TVoxel, TIndex> *scene, const View *view, CameraTrackingState *trackingState, RenderState *renderState,
                                    bool skipPoints, uint *noTotalPoints_device)
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f invM = trackingState->pose_d->GetInvM() * view->calib.trafo_rgb_to_depth.calib;

	GenericRaycast(scene, imgSize, invM, view->calib.intrinsics_rgb.projectionParamsSimple.all, renderState, true);
	trackingState->pose_pointCloud->SetFrom(trackingState->pose_d);

	ORcudaSafeCall(cudaMemsetAsync(noTotalPoints_device, 0, sizeof(uint)));

	Vector3f lightSource = -Vector3f(invM.getColumn(2));
	Vector4f *locations = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f *colours = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f *pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);

	dim3 cudaBlockSize(16, 16);
	dim3 gridSize = getGridSize(imgSize, cudaBlockSize);
	renderPointCloud_device<TVoxel, TIndex> << <gridSize, cudaBlockSize >> >(locations, colours, noTotalPoints_device,
		pointsRay, scene->voxels.GetVoxelBlocks(), scene->index.GetIndexData(), skipPoints, scene->parameters->voxel_size, imgSize, lightSource);
	ORcudaKernelCheck;

	ORcudaSafeCall(cudaMemcpy(&trackingState->pointCloud->noTotalPoints, noTotalPoints_device, sizeof(uint), cudaMemcpyDeviceToHost));
}

template<class TVoxel, class TIndex>
void CreateICPMaps_common(VoxelVolume<TVoxel, TIndex> *scene, const View *view, CameraTrackingState *trackingState, RenderState *renderState)
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f invM = trackingState->pose_d->GetInvM();

	GenericRaycast(scene, imgSize, invM, view->calib.intrinsics_d.projectionParamsSimple.all, renderState, true);
	trackingState->pose_pointCloud->SetFrom(trackingState->pose_d);

	Vector4f *pointsMap = trackingState->pointCloud->locations->GetData(MEMORYDEVICE_CUDA);
	Vector4f *normalsMap = trackingState->pointCloud->colours->GetData(MEMORYDEVICE_CUDA);
	Vector4f *pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	Vector3f lightSource = -Vector3f(invM.getColumn(2));

	dim3 cudaBlockSize(16, 12);
	dim3 gridSize((int)ceil((float)imgSize.x / (float)cudaBlockSize.x), (int)ceil((float)imgSize.y / (float)cudaBlockSize.y));

	if (view->calib.intrinsics_d.FocalLengthSignsDiffer())
	{
		renderICP_device<true> <<<gridSize, cudaBlockSize>>>(pointsMap, normalsMap, pointsRay,
			scene->parameters->voxel_size, imgSize, lightSource);
	}
	else
	{
		renderICP_device<false> <<<gridSize, cudaBlockSize>>>(pointsMap, normalsMap, pointsRay,
			scene->parameters->voxel_size, imgSize, lightSource);
	}
	ORcudaKernelCheck;
}

template<class TVoxel, class TIndex>
static void ForwardRender_common(const VoxelVolume<TVoxel, TIndex> *scene, const View *view, CameraTrackingState *trackingState, RenderState *renderState,
                                 uint *noTotalPoints_device)
{
	Vector2i imgSize = renderState->raycastResult->noDims;
	Matrix4f M = trackingState->pose_d->GetM();
	Matrix4f invM = trackingState->pose_d->GetInvM();
	const Vector4f& projParams = view->calib.intrinsics_d.projectionParamsSimple.all;

	const Vector4f *pointsRay = renderState->raycastResult->GetData(MEMORYDEVICE_CUDA);
	float *currentDepth = view->depth->GetData(MEMORYDEVICE_CUDA);
	Vector4f *forwardProjection = renderState->forwardProjection->GetData(MEMORYDEVICE_CUDA);
	int *fwdProjMissingPoints = renderState->fwdProjMissingPoints->GetData(MEMORYDEVICE_CUDA);
	const Vector2f *minmaximg = renderState->renderingRangeImage->GetData(MEMORYDEVICE_CUDA);
	float oneOverVoxelSize = 1.0f / scene->parameters->voxel_size;
	float voxelSize = scene->parameters->voxel_size;
	const TVoxel *voxelData = scene->voxels.GetVoxelBlocks();
	const typename TIndex::IndexData *voxelIndex = scene->index.GetIndexData();

	renderState->forwardProjection->Clear();

	dim3 blockSize, gridSize;

	{ // forward projection
		blockSize = dim3(16, 16);
		gridSize = dim3((int)ceil((float)imgSize.x / (float)blockSize.x), (int)ceil((float)imgSize.y / (float)blockSize.y));

		forwardProject_device << <gridSize, blockSize >> >(forwardProjection, pointsRay, imgSize, M, projParams, voxelSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(cudaMemset(noTotalPoints_device, 0, sizeof(uint)));

	{ // find missing points
		blockSize = dim3(16, 16);
		gridSize = dim3((int)ceil((float)imgSize.x / (float)blockSize.x), (int)ceil((float)imgSize.y / (float)blockSize.y));

		findMissingPoints_device << <gridSize, blockSize >> >(fwdProjMissingPoints, noTotalPoints_device, minmaximg, 
			forwardProjection, currentDepth, imgSize);
		ORcudaKernelCheck;
	}

	ORcudaSafeCall(cudaMemcpy(&renderState->noFwdProjMissingPoints, noTotalPoints_device, sizeof(uint), cudaMemcpyDeviceToHost));

	{ // render missing points
		blockSize = dim3(256);
		gridSize = dim3((int)ceil((float)renderState->noFwdProjMissingPoints / blockSize.x));

		genericRaycastMissingPoints_device<TVoxel, TIndex, false> << <gridSize, blockSize >> >(forwardProjection, NULL, voxelData, voxelIndex, imgSize, invM,
			InvertProjectionParams(projParams), oneOverVoxelSize, fwdProjMissingPoints, renderState->noFwdProjMissingPoints, minmaximg, scene->parameters->narrow_band_half_width);
		ORcudaKernelCheck;
	}
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::RenderImage(VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, const RenderState *renderState,
                                                           ITMUChar4Image *outputImage, IVisualizationEngine::RenderImageType type,
                                                           IVisualizationEngine::RenderRaycastSelection raycastType) const
{
	RenderImage_common(scene, pose, intrinsics, renderState, outputImage, type, raycastType);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::RenderImage(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics,
                                                                   const RenderState *renderState, ITMUChar4Image *outputImage, IVisualizationEngine::RenderImageType type,
                                                                   IVisualizationEngine::RenderRaycastSelection raycastType) const
{
	RenderImage_common(scene, pose, intrinsics, renderState, outputImage, type, raycastType);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::FindSurface(VoxelVolume<TVoxel,TIndex> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics, const RenderState *renderState) const
{
	GenericRaycast(scene, renderState->raycastResult->noDims, pose->GetInvM(), intrinsics->projectionParamsSimple.all, renderState, false);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::FindSurface(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const ORUtils::SE3Pose *pose, const Intrinsics *intrinsics,
                                                                   const RenderState *renderState) const
{
	GenericRaycast(scene, renderState->raycastResult->noDims, pose->GetInvM(), intrinsics->projectionParamsSimple.all, renderState, false);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::CreatePointCloud(VoxelVolume<TVoxel,TIndex> *scene, const View *view, CameraTrackingState *trackingState, RenderState *renderState,
                                                                bool skipPoints) const
{
	CreatePointCloud_common(scene, view, trackingState, renderState, skipPoints, noTotalPoints_device);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CreatePointCloud(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const View *view, CameraTrackingState *trackingState,
                                                                        RenderState *renderState, bool skipPoints) const
{
	CreatePointCloud_common(scene, view, trackingState, renderState, skipPoints, noTotalPoints_device);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::CreateICPMaps(VoxelVolume<TVoxel,TIndex> *scene, const View *view, CameraTrackingState *trackingState,
                                                             RenderState *renderState) const
{
	CreateICPMaps_common(scene, view, trackingState, renderState);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::CreateICPMaps(VoxelVolume<TVoxel,VoxelBlockHash> *scene, const View *view, CameraTrackingState *trackingState,
                                                                     RenderState *renderState) const
{
	CreateICPMaps_common(scene, view, trackingState, renderState);
}

template<class TVoxel, class TIndex>
void VisualizationEngine_CUDA<TVoxel, TIndex>::ForwardRender(const VoxelVolume<TVoxel,TIndex> *scene, const View *view, CameraTrackingState *trackingState,
                                                             RenderState *renderState) const
{
	ForwardRender_common(scene, view, trackingState, renderState, this->noTotalPoints_device);
}

template<class TVoxel>
void VisualizationEngine_CUDA<TVoxel, VoxelBlockHash>::ForwardRender(const VoxelVolume<TVoxel,VoxelBlockHash> *scene, const View *view, CameraTrackingState *trackingState,
                                                                     RenderState *renderState) const
{
	ForwardRender_common(scene, view, trackingState, renderState, this->noTotalPoints_device);
}
