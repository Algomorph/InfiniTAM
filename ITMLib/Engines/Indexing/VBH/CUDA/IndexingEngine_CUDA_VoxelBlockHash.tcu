//  ================================================================
//  Created by Gregory Kramida on 11/1/19.
//  Copyright (c) 2019 Gregory Kramida
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at

//  http://www.apache.org/licenses/LICENSE-2.0

//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//  ================================================================
#pragma once

//local
#include "IndexingEngine_CUDA_VoxelBlockHash.h"
#include "IndexingEngine_CUDA_VoxelBlockHash_Kernels.h"
#include "../../Interface/IndexingEngine.h"
#include "../../../../Utils/Configuration.h"
#include "../CPU/IndexingEngine_CPU_VoxelBlockHash.h"
#include "../../../../../ORUtils/PlatformIndependence.h"
#include "../../Shared/IndexingEngine_Functors.h"
#include "../../AtomicArrayThreadGuard/AtomicArrayThreadGuard_CUDA.h"


using namespace ITMLib;


template<typename TVoxel>
template<typename TVoxelTarget, typename TVoxelSource>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateUsingOtherVolume(
		VoxelVolume<TVoxelTarget, VoxelBlockHash>* targetVolume,
		VoxelVolume<TVoxelSource, VoxelBlockHash>* sourceVolume) {

	assert(targetVolume->index.hashEntryCount == sourceVolume->index.hashEntryCount);

	HashEntry* targetHashTable = targetVolume->index.GetIndexData();
	HashEntry* sourceHashTable = sourceVolume->index.GetIndexData();
	int hashEntryCount = targetVolume->index.hashEntryCount;

	HashEntryAllocationState* hashEntryStates_device = targetVolume->index.GetHashEntryAllocationStates();
	Vector3s* blockCoordinates_device = targetVolume->index.GetAllocationBlockCoordinates();

	ORUtils::MemoryBlock<bool> collisionDetected(1, true, true);

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	do {
		targetVolume->index.ClearHashEntryAllocationStates();
		*collisionDetected.GetData(MEMORYDEVICE_CPU) = false;
		collisionDetected.UpdateDeviceFromHost();


		buildHashAllocationTypeList_VolumeToVolume << < gridSizeAL, cudaBlockSizeAL >> > (
				hashEntryStates_device, blockCoordinates_device, targetHashTable, sourceHashTable,
						hashEntryCount, collisionDetected.GetData(MEMORYDEVICE_CUDA));
		ORcudaKernelCheck;

		IndexingEngine<TVoxelTarget, VoxelBlockHash, MEMORYDEVICE_CUDA>::Instance()
				.AllocateHashEntriesUsingLists(targetVolume);


		collisionDetected.UpdateHostFromDevice();
	} while (*collisionDetected.GetData(MEMORYDEVICE_CPU));
}

template<typename TVoxel>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::
AllocateHashEntriesUsingLists(VoxelVolume<TVoxel, VoxelBlockHash>* volume) {

	const HashEntryAllocationState* hashEntryAllocationStates_device = volume->index.GetHashEntryAllocationStates();
	Vector3s* allocationBlockCoordinates_device = volume->index.GetAllocationBlockCoordinates();

	const int hashEntryCount = volume->index.hashEntryCount;
	int* voxelAllocationList = volume->localVBA.GetAllocationList();
	int* excessAllocationList = volume->index.GetExcessAllocationList();
	HashEntry* hashTable = volume->index.GetIndexData();

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->last_free_voxel_block_id = volume->localVBA.lastFreeBlockId;
	allocationTempData_host->last_free_excess_list_id = volume->index.GetLastFreeExcessListId();
	allocationTempData.UpdateDeviceFromHost();

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	allocateHashedVoxelBlocksUsingLists_device << < gridSizeAL, cudaBlockSizeAL >> > (
			voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
					hashTable, hashEntryCount, hashEntryAllocationStates_device,
					allocationBlockCoordinates_device);
	ORcudaKernelCheck;
	allocationTempData.UpdateHostFromDevice();
	volume->localVBA.lastFreeBlockId = allocationTempData_host->last_free_voxel_block_id;
	volume->index.SetLastFreeExcessListId(allocationTempData_host->last_free_excess_list_id);
}


template<typename TVoxel>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::
AllocateHashEntriesUsingLists_SetVisibility(VoxelVolume<TVoxel, VoxelBlockHash>* volume) {

	const HashEntryAllocationState* hashEntryAllocationStates_device = volume->index.GetHashEntryAllocationStates();
	Vector3s* allocationBlockCoordinates_device = volume->index.GetAllocationBlockCoordinates();
	HashBlockVisibility* hashBlockVisibilityTypes_device = volume->index.GetBlockVisibilityTypes();

	const int hashEntryCount = volume->index.hashEntryCount;

	int* voxelAllocationList = volume->localVBA.GetAllocationList();
	int* excessAllocationList = volume->index.GetExcessAllocationList();
	HashEntry* hashTable = volume->index.GetIndexData();

	ORUtils::MemoryBlock<AllocationTempData> allocationTempData(1, true, true);
	AllocationTempData* allocationTempData_host = allocationTempData.GetData(MEMORYDEVICE_CPU);
	allocationTempData_host->last_free_voxel_block_id = volume->localVBA.lastFreeBlockId;
	allocationTempData_host->last_free_excess_list_id = volume->index.GetLastFreeExcessListId();
	allocationTempData.UpdateDeviceFromHost();

	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	allocateHashedVoxelBlocksUsingLists_SetVisibility_device << < gridSizeAL, cudaBlockSizeAL >> > (
			voxelAllocationList, excessAllocationList, allocationTempData.GetData(MEMORYDEVICE_CUDA),
					hashTable, hashEntryCount, hashEntryAllocationStates_device,
					allocationBlockCoordinates_device, hashBlockVisibilityTypes_device);
	ORcudaKernelCheck;
	allocationTempData.UpdateHostFromDevice();
	volume->localVBA.lastFreeBlockId = allocationTempData_host->last_free_voxel_block_id;
	volume->index.SetLastFreeExcessListId(allocationTempData_host->last_free_excess_list_id);
}


template<typename TVoxel>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateBlockList(
		VoxelVolume<TVoxel, VoxelBlockHash>* volume, const ORUtils::MemoryBlock<Vector3s>& block_coordinates,
		const int new_block_count) {
	int entry_count = volume->index.hashEntryCount;

	AllocationCounters<MEMORYDEVICE_CUDA> counters(volume->localVBA.lastFreeBlockId,
	                                               volume->index.GetLastFreeExcessListId());
	AllocationCounters<MEMORYDEVICE_CUDA>* counters_device;
	ORcudaSafeCall(cudaMalloc((void**) &counters_device, sizeof(AllocationCounters<MEMORYDEVICE_CUDA>)));
	ORcudaSafeCall(cudaMemcpy(counters_device, &counters, sizeof(AllocationCounters<MEMORYDEVICE_CUDA>),
	                          cudaMemcpyHostToDevice));

	int* block_allocation_list = volume->localVBA.GetAllocationList();
	int* excess_allocation_list = volume->index.GetExcessAllocationList();

	AtomicArrayThreadGuard<MEMORYDEVICE_CUDA> guard(entry_count);
	AtomicArrayThreadGuard<MEMORYDEVICE_CUDA>* guard_device;
	ORcudaSafeCall(cudaMalloc((void**) &guard_device, sizeof(AtomicArrayThreadGuard<MEMORYDEVICE_CUDA>)));
	ORcudaSafeCall(cudaMemcpy(guard_device, &guard, sizeof(AtomicArrayThreadGuard<MEMORYDEVICE_CUDA>),
	                          cudaMemcpyHostToDevice));


	HashEntry* hash_table = volume->index.GetEntries();
	const Vector3s* block_coordinates_device = block_coordinates.GetData(MEMORYDEVICE_CUDA);

	dim3 cuda_block_size(256);
	dim3 cuda_grid_size(
			static_cast<int>(ceil(static_cast<float>(new_block_count) / static_cast<float>(cuda_block_size.x))));

	allocateBlock_device
			<< < cuda_grid_size, cuda_block_size >> >
	                             (block_coordinates.GetData(
			                             MEMORYDEVICE_CUDA), hash_table, guard_device, counters_device,
			                             block_allocation_list, excess_allocation_list, new_block_count);

	ORcudaKernelCheck;

	ORcudaSafeCall(cudaFree(guard_device));
	ORcudaSafeCall(cudaMemcpy(&counters, counters_device, sizeof(AllocationCounters<MEMORYDEVICE_CUDA>),
	                          cudaMemcpyDeviceToHost));
	ORcudaSafeCall(cudaFree(counters_device));

	volume->localVBA.lastFreeBlockId = counters.GetLastFreeVoxelBlockId();
	volume->index.SetLastFreeExcessListId(counters.GetLastFreeExcesListId());
}


template<typename TVoxel>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::BuildUtilizedBlockListBasedOnVisibility(
		VoxelVolume<TVoxel, VoxelBlockHash>* volume, const ITMView* view,
		const Matrix4f& depth_camera_matrix) {

	// ** volume data **
	const int hashEntryCount = volume->index.hashEntryCount;
	HashBlockVisibility* hashBlockVisibilityTypes_device = volume->index.GetBlockVisibilityTypes();
	int* visibleBlockHashCodes_device = volume->index.GetUtilizedBlockHashCodes();
	HashEntry* hashTable = volume->index.GetEntries();
	bool useSwapping = volume->globalCache != nullptr;
	ITMHashSwapState* swapStates = volume->Swapping() ? volume->globalCache->GetSwapStates(false) : 0;

	// ** view data **
	Vector4f depthCameraProjectionParameters = view->calib.intrinsics_d.projectionParamsSimple.all;
	Vector2i depthImgSize = view->depth->noDims;
	float voxelSize = volume->sceneParams->voxel_size;


	// ** CUDA data **
	ORUtils::MemoryBlock<int> visibleBlockCount(1, true, true);
	dim3 cudaBlockSizeAL(256, 1);
	dim3 gridSizeAL((int) ceil((float) hashEntryCount / (float) cudaBlockSizeAL.x));

	if (useSwapping) {
		buildVisibilityList_device<true> << < gridSizeAL, cudaBlockSizeAL >> >
		                                                  (hashTable, swapStates, hashEntryCount, visibleBlockHashCodes_device,
				                                                  visibleBlockCount.GetData(
						                                                  MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device, depth_camera_matrix, depthCameraProjectionParameters, depthImgSize, voxelSize);
		ORcudaKernelCheck;
	} else {
		buildVisibilityList_device<false> << < gridSizeAL, cudaBlockSizeAL >> >
		                                                   (hashTable, swapStates, hashEntryCount, visibleBlockHashCodes_device,
				                                                   visibleBlockCount.GetData(
						                                                   MEMORYDEVICE_CUDA), hashBlockVisibilityTypes_device, depth_camera_matrix, depthCameraProjectionParameters, depthImgSize, voxelSize);
		ORcudaKernelCheck;
	}
	visibleBlockCount.UpdateHostFromDevice();
	volume->index.SetUtilizedHashBlockCount(*visibleBlockCount.GetData(MEMORYDEVICE_CPU));
}

template<typename TVoxel>
void
IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::SetVisibilityToVisibleAtPreviousFrameAndUnstreamed(
		VoxelVolume<TVoxel, VoxelBlockHash>* volume) {
	HashBlockVisibility* utilized_block_visibility_types = volume->index.GetBlockVisibilityTypes();
	const int* utilized_block_hash_codes = volume->index.GetUtilizedBlockHashCodes();
	const int utilized_block_count = volume->index.GetUtilizedHashBlockCount();
	dim3 cudaBlockSizeVS(256, 1);
	dim3 gridSizeVS((int) ceil((float) utilized_block_count / (float) cudaBlockSizeVS.x));
	if (gridSizeVS.x > 0) {
		setVisibleEntriesToVisibleAtPreviousFrameAndUnstreamed << < gridSizeVS, cudaBlockSizeVS >> >
		                                                                        (utilized_block_visibility_types,
				                                                                        utilized_block_hash_codes, utilized_block_count);
		ORcudaKernelCheck;
	}
}

template<typename TVoxel>
HashEntry
IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::FindHashEntry(const VoxelBlockHash& index,
                                                                         const Vector3s& coordinates) {
	const HashEntry* entries = index.GetEntries();
	ORUtils::MemoryBlock<int> hashCode(1, true, true);
	ORUtils::MemoryBlock<HashEntry> hashEntry(1, true, true);
	findHashEntry_device << < 1, 1 >> > (hashEntry.GetData(MEMORYDEVICE_CUDA), entries, coordinates, hashCode.GetData(
			MEMORYDEVICE_CUDA));
	hashEntry.UpdateHostFromDevice();
	hashCode.UpdateHostFromDevice();
	int hashCode_CPU = *hashCode.GetData(MEMORYDEVICE_CPU);
	if (hashCode_CPU == -1) {
		return {Vector3s(0, 0, 0), 0, -2};
	} else {
		HashEntry entry = *hashEntry.GetData(MEMORYDEVICE_CPU);
		return entry;
	}
}


template<typename TVoxel>
HashEntry
IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::FindHashEntry(const VoxelBlockHash& index,
                                                                         const Vector3s& coordinates,
                                                                         int& hashCode_CPU) {
	const HashEntry* entries = index.GetEntries();
	ORUtils::MemoryBlock<int> hashCode(1, true, true);
	ORUtils::MemoryBlock<HashEntry> hashEntry(1, true, true);
	findHashEntry_device << < 1, 1 >> > (hashEntry.GetData(MEMORYDEVICE_CUDA), entries, coordinates, hashCode.GetData(
			MEMORYDEVICE_CUDA));
	ORcudaKernelCheck;
	hashEntry.UpdateHostFromDevice();
	hashCode.UpdateHostFromDevice();
	hashCode_CPU = *hashCode.GetData(MEMORYDEVICE_CPU);
	if (hashCode_CPU == -1) {
		return {Vector3s(0, 0, 0), 0, -2};
	} else {
		HashEntry entry = *hashEntry.GetData(MEMORYDEVICE_CPU);
		return entry;
	}
}

template<typename TVoxel>
template<typename TVoxelTarget, typename TVoxelSource>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateUsingOtherVolumeExpanded(
		VoxelVolume<TVoxelTarget, VoxelBlockHash>* targetVolume,
		VoxelVolume<TVoxelSource, VoxelBlockHash>* sourceVolume) {
	assert(sourceVolume->index.hashEntryCount == targetVolume->index.hashEntryCount);

	int hashEntryCount = targetVolume->index.hashEntryCount;
	HashEntry* targetHashTable = targetVolume->index.GetEntries();
	HashEntry* sourceHashTable = sourceVolume->index.GetEntries();

	HashEntryAllocationState* hashEntryStates_device = targetVolume->index.GetHashEntryAllocationStates();
	Vector3s* blockCoordinates_device = targetVolume->index.GetAllocationBlockCoordinates();

	ORUtils::MemoryBlock<bool> collision_detected(1, true, true);
	dim3 cudaBlockSize_27Neighborhood(3, 3, 3);
	dim3 gridSize_AllHashEntries(hashEntryCount);
	do {
		*collision_detected.GetData(MEMORYDEVICE_CPU) = false;
		collision_detected.UpdateDeviceFromHost();
		targetVolume->index.ClearHashEntryAllocationStates();
		markForAllocationBasedOnOneRingAroundAnotherAllocation_device
				<< < gridSize_AllHashEntries, cudaBlockSize_27Neighborhood >> >
		                                      (hashEntryStates_device, blockCoordinates_device,
				                                      sourceHashTable, targetHashTable, hashEntryCount,
				                                      collision_detected.GetData(MEMORYDEVICE_CUDA));
		ORcudaKernelCheck;
		collision_detected.UpdateHostFromDevice();
		IndexingEngine<TVoxelTarget, VoxelBlockHash, MEMORYDEVICE_CUDA>::Instance()
				.AllocateHashEntriesUsingLists(targetVolume);
	} while (*collision_detected.GetData(MEMORYDEVICE_CPU));
}

template<typename TVoxel>
template<typename TVoxelTarget, typename TVoxelSource>
void IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateUsingOtherVolumeAndSetVisibilityExpanded(
		VoxelVolume<TVoxelTarget, VoxelBlockHash>* targetVolume,
		VoxelVolume<TVoxelSource, VoxelBlockHash>* sourceVolume,
		ITMView* view, const Matrix4f& depth_camera_matrix) {

	assert(sourceVolume->index.hashEntryCount == targetVolume->index.hashEntryCount);

	int hashEntryCount = targetVolume->index.hashEntryCount;
	HashEntry* targetHashTable = targetVolume->index.GetEntries();
	HashEntry* sourceHashTable = sourceVolume->index.GetEntries();

	HashEntryAllocationState* hashEntryStates_device = targetVolume->index.GetHashEntryAllocationStates();
	Vector3s* blockCoordinates_device = targetVolume->index.GetAllocationBlockCoordinates();
	HashBlockVisibility* hashBlockVisibilityTypes_device = targetVolume->index.GetBlockVisibilityTypes();

	ORUtils::MemoryBlock<bool> collision_detected(1, true, true);
	dim3 cudaBlockSize_27Neighborhood(3, 3, 3);
	dim3 gridSize_AllHashEntries(hashEntryCount);

	SetVisibilityToVisibleAtPreviousFrameAndUnstreamed(nullptr);
	do {
		*collision_detected.GetData(MEMORYDEVICE_CPU) = false;
		collision_detected.UpdateDeviceFromHost();
		targetVolume->index.ClearHashEntryAllocationStates();
		markForAllocationAndSetVisibilityBasedOnOneRingAroundAnotherAllocation_device
				<< < gridSize_AllHashEntries, cudaBlockSize_27Neighborhood >> >
		                                      (hashEntryStates_device, blockCoordinates_device, hashBlockVisibilityTypes_device,
				                                      sourceHashTable, targetHashTable, hashEntryCount,
				                                      collision_detected.GetData(MEMORYDEVICE_CUDA));
		ORcudaKernelCheck;
		collision_detected.UpdateHostFromDevice();
		IndexingEngine<TVoxelTarget, VoxelBlockHash, MEMORYDEVICE_CUDA>::Instance()
				.AllocateHashEntriesUsingLists(targetVolume);
	} while (*collision_detected.GetData(MEMORYDEVICE_CPU));

	IndexingEngine<TVoxelTarget, VoxelBlockHash, MEMORYDEVICE_CUDA>::Instance().BuildUtilizedBlockListBasedOnVisibility(
			targetVolume, view, depth_camera_matrix);
}


template<typename TVoxel>
bool IndexingEngine<TVoxel, VoxelBlockHash, MEMORYDEVICE_CUDA>::AllocateHashBlockAt(
		VoxelVolume<TVoxel, VoxelBlockHash>* volume, Vector3s at, int& hashCode) {
	HashEntry* hashTable = volume->index.GetEntries();

	ORUtils::MemoryBlock<SingleHashAllocationData> data(1, true, true);

	SingleHashAllocationData* data_CPU = data.GetData(MEMORYDEVICE_CPU);
	data_CPU->lastFreeVoxelBlockId = volume->localVBA.lastFreeBlockId;
	data_CPU->lastFreeExcessListId = volume->index.GetLastFreeExcessListId();
	data_CPU->hashCode = -1;
	data_CPU->success = false;
	data.UpdateDeviceFromHost();

	int* voxelAllocationList = volume->localVBA.GetAllocationList();
	int* excessAllocationList = volume->index.GetExcessAllocationList();

	allocateHashEntry_device << < 1, 1 >> >
	                                 (data.GetData(
			                                 MEMORYDEVICE_CUDA), at, hashTable, voxelAllocationList, excessAllocationList);

	ORcudaKernelCheck;
	data.UpdateHostFromDevice();

	if (!data_CPU->success) {
		return false;
	}

	hashCode = data_CPU->hashCode;

	volume->localVBA.lastFreeBlockId = data_CPU->lastFreeVoxelBlockId;
	volume->index.SetLastFreeExcessListId(data_CPU->lastFreeExcessListId);
	return true;
}


