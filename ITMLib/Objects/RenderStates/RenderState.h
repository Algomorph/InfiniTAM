// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#pragma once

#ifndef __METALC__

#include "../../Utils/Math.h"
#include "../../../ORUtils/Image.h"

namespace ITMLib
{
	/** \brief
		Stores the render state used by the SceneReconstruction
		and Rendering engines.
		*/
	class RenderState
	{
	public:
		/** @brief
		Gives the raycasting operations an idea of the
		depth range to cover

		Each pixel contains an expected minimum and maximum
		depth. The raycasting step would use this
		information to reduce the range for searching an
		intersection with the actual surface. Should be
		updated by a ITMLib::Engine::VisualizationEngine
		before any raycasting operation.
		*/
		ORUtils::Image<Vector2f> *renderingRangeImage;

		/** @brief
		Float rendering output of the scene, containing the 3D
		locations in the world generated by the raycast.

		This is typically created as a by-product of
		raycasting operations.
		*/
		ORUtils::Image<Vector4f> *raycastResult;

		ORUtils::Image<Vector4f> *forwardProjection;
		ORUtils::Image<int> *fwdProjMissingPoints;
		int noFwdProjMissingPoints;

		ORUtils::Image<Vector4u> *raycastImage;

		RenderState(const Vector2i& image_size, float near_clipping_distance, float far_clipping_distance, MemoryDeviceType memory_type)
		{
			renderingRangeImage = new ORUtils::Image<Vector2f>(image_size, memory_type);
			raycastResult = new ORUtils::Image<Vector4f>(image_size, memory_type);
			forwardProjection = new ORUtils::Image<Vector4f>(image_size, memory_type);
			fwdProjMissingPoints = new ORUtils::Image<int>(image_size, memory_type);
			raycastImage = new ORUtils::Image<Vector4u>(image_size, memory_type);

			ORUtils::Image<Vector2f> buffer_image(image_size, MEMORYDEVICE_CPU);

			Vector2f clipping_distances(near_clipping_distance, far_clipping_distance);
			for (int i = 0; i < image_size.x * image_size.y; i++) buffer_image.GetData(MEMORYDEVICE_CPU)[i] = clipping_distances;

			if (memory_type == MEMORYDEVICE_CUDA)
			{
#ifndef COMPILE_WITHOUT_CUDA
				renderingRangeImage->SetFrom(buffer_image, MemoryCopyDirection::CPU_TO_CUDA);
#endif
			}
			else renderingRangeImage->SetFrom(buffer_image, MemoryCopyDirection::CPU_TO_CPU);

			noFwdProjMissingPoints = 0;
		}

		virtual ~RenderState()
		{
			delete renderingRangeImage;
			delete raycastResult;
			delete forwardProjection;
			delete fwdProjMissingPoints;
			delete raycastImage;
		}
	};
}

#endif
